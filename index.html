<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Debate Research - Alfred Nobel</title>
  <style>
    :root {
      --bg: #0a0c13;
      --ink: #e7ecf2;
      --accent: #6ef3ff;
      --accent-2: #ff6bcb;
      --muted: #aab3c2;
      --card: #121725;
      --border: #1f2a3f;
      --tag: #1a2133;
      --glow: 0 0 24px rgba(110, 243, 255, 0.18);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", "Eurostile", "Arial", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(1200px 700px at 10% -10%, rgba(110, 243, 255, 0.18), transparent 60%),
        radial-gradient(900px 600px at 110% 10%, rgba(255, 107, 203, 0.15), transparent 55%),
        linear-gradient(180deg, #0a0c13 0%, #0b1020 60%, #0c1326 100%);
    }
    header {
      padding: 32px 20px 18px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(120deg, rgba(18, 23, 37, 0.9) 0%, rgba(10, 12, 19, 0.9) 100%);
      backdrop-filter: blur(8px);
    }
    h1 {
      margin: 0 0 8px;
      font-size: 30px;
      letter-spacing: 1px;
      text-transform: uppercase;
      text-shadow: var(--glow);
    }
    p.subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }
    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px 20px 40px;
    }
    .controls {
      display: grid;
      grid-template-columns: 1fr 180px 180px 180px 180px;
      gap: 12px;
      margin: 18px 0 22px;
    }
    input, select, button {
      font-family: inherit;
      padding: 12px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0f1424;
      color: var(--ink);
      box-shadow: inset 0 0 0 1px rgba(110, 243, 255, 0.08);
    }
    button {
      background: linear-gradient(135deg, #1ad1ff 0%, #6ef3ff 100%);
      color: #0a0c13;
      cursor: pointer;
      border: none;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }
    button.secondary {
      background: #1b2236;
      color: var(--ink);
    }
    .stats {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 10px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
      gap: 14px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25), var(--glow);
      display: grid;
      gap: 10px;
    }
    .card h3 {
      margin: 0;
      font-size: 16px;
      color: var(--accent);
      letter-spacing: 0.4px;
    }
    .label {
      font-weight: 700;
      color: var(--accent-2);
      font-size: 12px;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      margin: 10px 0 4px;
    }
    .text {
      font-size: 14px;
      line-height: 1.4;
    }
    .sources {
      font-size: 12px;
      color: var(--muted);
    }
    .sources a { color: var(--accent); text-decoration: none; }
    .sources a:hover { text-decoration: underline; }
    .status {
      font-size: 12px;
      color: var(--muted);
    }
    .card-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    footer {
      margin-top: 28px;
      font-size: 12px;
      color: var(--muted);
    }
    @media (max-width: 1100px) {
      .controls { grid-template-columns: 1fr 1fr 1fr; }
    }
    @media (max-width: 720px) {
      .controls { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Debate Research: Alfred Nobel</h1>
      <p class="subtitle">Auto‑summaries from hosted sources. Balanced, evidence‑based debate prep. (No Wikipedia.)</p>
    </div>
  </header>

  <main class="wrap">
    <div class="controls">
      <input id="q" type="search" placeholder="Search titles, URLs, summaries…" />
      <select id="filter">
        <option value="">All sources</option>
        <option value="summarized">Summarized only</option>
        <option value="missing">Missing summaries</option>
      </select>
      <button id="summarize">Summarize All</button>
      <button id="export">Export Summaries</button>
      <button id="reset" class="secondary">Reset Summaries</button>
    </div>

    <div class="stats" id="stats"></div>
    <div class="grid" id="grid"></div>

    <footer>
      Built for debate prep. Criticisms are extracted only when the source text explicitly supports them.
    </footer>
  </main>

<script>
let SOURCES = [];

const stopWords = new Set([
  "the","and","a","an","to","of","in","for","on","with","at","by","from",
  "as","is","are","was","were","be","this","that","it","or","but","not",
  "they","their","his","her","he","she","we","you","i","our"
]);
const limitationKeywords = [
  "influence", "impact", "legacy", "recognition", "credit", "attribution",
  "limited", "limit", "scope", "extent", "modest", "minor", "debate",
  "dispute", "controvers", "myth", "overstated", "exaggerated",
  "evidence", "historian", "scholar", "question", "doubt", "reassess",
  "comparison", "relative", "overshadow", "lesser", "critic", "critique",
  "criticism", "scandal", "politic", "bias", "omission", "snub",
  "legitimacy", "ethic", "protest", "opposition", "contested", "challenged",
  "arms", "military", "weapon", "explosive", "merchant of death"
];

const personalLifeKeywords = [
  "marriage", "married", "spouse", "husband", "wife", "affair",
  "family", "children", "child", "parent", "mother", "father",
  "romance", "love", "relationship", "divorce"
];

const qInput = document.getElementById("q");
const filterSelect = document.getElementById("filter");
const grid = document.getElementById("grid");
const stats = document.getElementById("stats");
const resetBtn = document.getElementById("reset");
const exportBtn = document.getElementById("export");
const summarizeBtn = document.getElementById("summarize");

const state = {
  summaries: loadSummaries(),
  status: {},
};

async function loadSources() {
  try {
    const response = await fetch("/sources.json", { cache: "no-store" });
    if (!response.ok) return;
    const data = await response.json();
    if (Array.isArray(data)) {
      SOURCES = data.filter((item) => item && item.url);
    }
  } catch (error) {
    // ignore
  }
}

function tokenize(text) {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .split(/\s+/)
    .filter((token) => token && !stopWords.has(token));
}

function scoreSentences(sentences) {
  const tokens = tokenize(sentences.join(" "));
  const freq = new Map();
  tokens.forEach((token) => freq.set(token, (freq.get(token) || 0) + 1));

  return sentences.map((sentence) => {
    const words = tokenize(sentence);
    const score = words.reduce((sum, word) => sum + (freq.get(word) || 0), 0);
    return { sentence, score: score / Math.max(words.length, 1) };
  });
}

function summarize(text, maxSentences = 2) {
  if (!text.trim()) return "";
  const sentences = text
    .replace(/\s+/g, " ")
    .split(/(?<=[.!?])\s+/)
    .filter(Boolean);
  if (sentences.length <= maxSentences) return sentences.join(" ");

  const scored = scoreSentences(sentences);
  const top = [...scored]
    .sort((a, b) => b.score - a.score)
    .slice(0, maxSentences)
    .sort((a, b) => sentences.indexOf(a.sentence) - sentences.indexOf(b.sentence))
    .map((item) => item.sentence);

  return top.join(" ");
}

function extractEvidence(text, maxItems = 2) {
  const sentences = text
    .replace(/\s+/g, " ")
    .split(/(?<=[.!?])\s+/)
    .filter((sentence) => sentence.length > 40);
  const scored = scoreSentences(sentences);
  return scored
    .sort((a, b) => b.score - a.score)
    .slice(0, maxItems)
    .map((item) => item.sentence);
}

function extractCriticisms(text, maxItems = 6) {
  const sentences = text
    .replace(/\\s+/g, " ")
    .split(/(?<=[.!?])\\s+/)
    .map((s) => s.trim())
    .filter((sentence) => sentence.length > 40 && sentence.length < 420);

  const hits = sentences.filter((sentence) => {
    const lower = sentence.toLowerCase();
    const hasLimitation = limitationKeywords.some((key) => lower.includes(key));
    const hasPersonal = personalLifeKeywords.some((key) => lower.includes(key));
    return hasLimitation && !hasPersonal;
  });

  if (hits.length === 0) {
    return [];
  }
  const scored = scoreSentences(hits);
  return scored
    .sort((a, b) => b.score - a.score)
    .slice(0, maxItems)
    .map((item) => item.sentence);
}
function loadSummaries() {
  try {
    const raw = localStorage.getItem("nobel-summaries");
    return raw ? JSON.parse(raw) : {};
  } catch {
    return {};
  }
}

function saveSummaries() {
  localStorage.setItem("nobel-summaries", JSON.stringify(state.summaries));
}

function getSummary(url) {
  return state.summaries[url] || null;
}

function setSummary(url, criticisms) {
  state.summaries[url] = { criticisms, updatedAt: Date.now() };
  saveSummaries();
}

function setStatus(url, message) {
  state.status[url] = message;
}

async function fetchAndSummarize(source) {
  if (getSummary(source.url)) return;
  setStatus(source.url, "Summarizing...");
  render();

  try {
    const response = await fetch("/api/summarize", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ url: source.url })
    });

    if (!response.ok) {
      const data = await response.json().catch(() => ({}));
      throw new Error(data.error || `Server error: ${response.status}`);
    }

    const data = await response.json();
    if (!data.text) throw new Error("No readable text found.");
    const criticisms = extractCriticisms(data.text, 8);
    state.summaries[source.url] = { criticisms, updatedAt: Date.now() };
    saveSummaries();
    setStatus(source.url, "Auto summary complete.");
  } catch (error) {
    setStatus(source.url, `Failed: ${error.message}`);
  }

  render();
}

async function summarizeAll() {
  for (const source of SOURCES) {
    await fetchAndSummarize(source);
    await new Promise((resolve) => setTimeout(resolve, 150));
  }
}

function render() {
  const query = qInput.value.trim().toLowerCase();
  const filter = filterSelect.value;

  const items = SOURCES.filter((source) => {
    const stored = getSummary(source.url);
    const summaryText = stored?.summary || "";
    const evidenceText = (stored?.evidence || []).join(" ");
    const haystack = `${source.title} ${source.url} ${summaryText} ${evidenceText}`.toLowerCase();
    const matchesQuery = !query || haystack.includes(query);
    const hasSummary = Boolean(stored);
    const matchesFilter =
      !filter ||
      (filter === "summarized" && hasSummary) ||
      (filter === "missing" && !hasSummary);
    return matchesQuery && matchesFilter;
  });

  stats.textContent = `${items.length} shown • ${SOURCES.length} total`;
  grid.innerHTML = "";

  items.forEach((source) => {
    const stored = getSummary(source.url);
    const card = document.createElement("div");
    card.className = "card";

    const title = document.createElement("h3");
    title.textContent = source.title;

    const link = document.createElement("div");
    link.className = "sources";
    link.innerHTML = `<a href="${source.url}" target="_blank" rel="noopener">${source.url}</a>`;

    const criticisms = document.createElement("div");
    criticisms.className = "text";
    criticisms.textContent = stored?.criticisms?.length
      ? stored.criticisms.join(" ")
      : "No relevant limitations found in this source.";

    const status = document.createElement("div");
    status.className = "status";
    status.textContent = state.status[source.url] || "";

    const actions = document.createElement("div");
    actions.className = "card-actions";

    const summarizeBtn = document.createElement("button");
    summarizeBtn.textContent = "Re-summarize";
    summarizeBtn.addEventListener("click", async () => {
      delete state.summaries[source.url];
      saveSummaries();
      await fetchAndSummarize(source);
    });

    const clearBtn = document.createElement("button");
    clearBtn.className = "secondary";
    clearBtn.textContent = "Clear";
    clearBtn.addEventListener("click", () => {
      delete state.summaries[source.url];
      saveSummaries();
      render();
    });

    actions.append(summarizeBtn, clearBtn);
    card.append(title, link, criticisms, status, actions);
    grid.appendChild(card);
  });
}

qInput.addEventListener("input", render);
filterSelect.addEventListener("change", render);

resetBtn.addEventListener("click", () => {
  if (!confirm("Clear all saved summaries?")) return;
  state.summaries = {};
  saveSummaries();
  render();
});

exportBtn.addEventListener("click", () => {
  const rows = SOURCES.map((source) => {
    const stored = getSummary(source.url) || { criticisms: [] };
    return {
      title: source.title,
      url: source.url,
      criticisms: stored.criticisms.join(" "),
    };
  });
  const blob = new Blob([JSON.stringify(rows, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = "nobel-summaries.json";
  link.click();
  URL.revokeObjectURL(url);
});

summarizeBtn.addEventListener("click", () => {
  summarizeAll();
});

render();

// Auto-summarize on load after sources are loaded.
window.addEventListener("load", async () => {
  await loadSources();
  render();
  summarizeAll();
});
</script>
</body>
</html>
